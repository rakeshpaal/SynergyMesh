#!/usr/bin/env python3
"""
Controlplane CLI - å¯¦ç”¨å‘½ä»¤è¡Œå·¥å…·
è®“ controlplane é…ç½®çœŸæ­£å¯ç”¨
"""

import sys
import os
import yaml
import json
import argparse
from pathlib import Path
from typing import Dict, Any, List, Optional

REPO_ROOT = Path(__file__).resolve().parent.parent
LIB_PATH = REPO_ROOT / "lib"
MODULE_NAME_AS = "file"  # æ¨¡çµ„ç›®å‰æ²¿ç”¨æª”æ¡ˆå‘½åè¦å‰‡
NAME_TYPE_MAP = {"module": MODULE_NAME_AS}
if str(LIB_PATH) not in sys.path:
    sys.path.insert(0, str(LIB_PATH))

from controlplane import validate_name as cp_validate_name

class ControlplaneCLI:
    """Controlplane å‘½ä»¤è¡Œæ¥å£"""
    
    def __init__(self):
        self.repo_root = self._find_repo_root()
        self.baseline_path = self.repo_root / "controlplane" / "baseline"
        self.overlay_path = self.repo_root / "controlplane" / "overlay"
        self.active_path = self.repo_root / "controlplane" / "active"
        
    def _find_repo_root(self) -> Path:
        """æ‰¾åˆ°å„²å­˜åº«æ ¹ç›®éŒ„"""
        current = Path.cwd()
        while current != current.parent:
            if (current / ".git").exists():
                return current
            current = current.parent
        return Path.cwd()
    
    def _load_yaml(self, file_path: Path) -> Dict[str, Any]:
        """è¼‰å…¥ YAML æ–‡ä»¶"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f) or {}
        except Exception as e:
            print(f"âŒ ç„¡æ³•è¼‰å…¥ {file_path}: {e}", file=sys.stderr)
            return {}
    
    def _save_yaml(self, file_path: Path, data: Dict[str, Any]):
        """ä¿å­˜ YAML æ–‡ä»¶"""
        file_path.parent.mkdir(parents=True, exist_ok=True)
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.dump(data, f, default_flow_style=False, allow_unicode=True)
    
    def get_config(self, key: str) -> Any:
        """ç²å–é…ç½®å€¼"""
        # å¾ baseline è®€å–
        config_file = self.baseline_path / "config" / "root.config.yaml"
        config = self._load_yaml(config_file)
        
        # æ”¯æŒé»è™Ÿè·¯å¾‘ (ä¾‹å¦‚: metadata.version)
        keys = key.split('.')
        value = config
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
            else:
                return None
        
        return value
    
    def list_modules(self) -> List[Dict[str, Any]]:
        """åˆ—å‡ºæ‰€æœ‰æ¨¡çµ„"""
        modules_file = self.baseline_path / "registries" / "root.registry.modules.yaml"
        data = self._load_yaml(modules_file)
        return data.get('modules', [])
    
    def list_namespaces(self) -> List[Dict[str, Any]]:
        """åˆ—å‡ºæ‰€æœ‰å‘½åç©ºé–“"""
        ns_file = self.baseline_path / "registries" / "root.registry.namespaces.yaml"
        data = self._load_yaml(ns_file)
        return data.get('namespaces', [])
    
    def validate(self, verbose: bool = False) -> bool:
        """é‹è¡Œé©—è­‰"""
        validator_script = self.baseline_path / "validation" / "validate-root-specs.py"
        
        if not validator_script.exists():
            print("âŒ é©—è­‰è…³æœ¬ä¸å­˜åœ¨", file=sys.stderr)
            return False
        
        import subprocess
        cmd = [sys.executable, str(validator_script)]
        if verbose:
            cmd.append("--verbose")
        
        result = subprocess.run(cmd, cwd=self.repo_root)
        return result.returncode == 0
    
    def show_status(self):
        """é¡¯ç¤º controlplane ç‹€æ…‹"""
        print("ğŸ›ï¸  Controlplane ç‹€æ…‹")
        print("=" * 60)
        print(f"ğŸ“ å„²å­˜åº«æ ¹ç›®éŒ„: {self.repo_root}")
        print(f"ğŸ“‹ Baseline è·¯å¾‘: {self.baseline_path}")
        print(f"ğŸ“ Overlay è·¯å¾‘: {self.overlay_path}")
        print(f"âš¡ Active è·¯å¾‘: {self.active_path}")
        print()
        
        # æª¢æŸ¥ç›®éŒ„å­˜åœ¨æ€§
        print("ç›®éŒ„ç‹€æ…‹:")
        print(f"  Baseline: {'âœ… å­˜åœ¨' if self.baseline_path.exists() else 'âŒ ä¸å­˜åœ¨'}")
        print(f"  Overlay:  {'âœ… å­˜åœ¨' if self.overlay_path.exists() else 'âŒ ä¸å­˜åœ¨'}")
        print(f"  Active:   {'âœ… å­˜åœ¨' if self.active_path.exists() else 'âŒ ä¸å­˜åœ¨'}")
        print()
        
        # çµ±è¨ˆæ–‡ä»¶æ•¸é‡
        if self.baseline_path.exists():
            config_count = len(list((self.baseline_path / "config").glob("*.yaml")))
            spec_count = len(list((self.baseline_path / "specifications").glob("*.yaml")))
            reg_count = len(list((self.baseline_path / "registries").glob("*.yaml")))
            
            print("Baseline å…§å®¹:")
            print(f"  é…ç½®æ–‡ä»¶: {config_count}")
            print(f"  è¦ç¯„æ–‡ä»¶: {spec_count}")
            print(f"  è¨»å†Šè¡¨æ–‡ä»¶: {reg_count}")
    
    def get_naming_rules(self) -> Dict[str, Any]:
        """ç²å–å‘½åè¦å‰‡"""
        naming_file = self.baseline_path / "config" / "root.naming-policy.yaml"
        return self._load_yaml(naming_file)
    
    def check_name(self, name: str, name_type: str = "file") -> bool:
        """æª¢æŸ¥åç¨±æ˜¯å¦ç¬¦åˆè¦ç¯„"""
        resolved_type = NAME_TYPE_MAP.get(name_type, name_type)
        is_valid, _ = cp_validate_name(name, resolved_type)
        return is_valid
    
    def create_overlay_extension(self, name: str, extends: str, config: Dict[str, Any]):
        """å‰µå»º overlay æ“´å±•"""
        overlay_config_dir = self.overlay_path / "config"
        overlay_config_dir.mkdir(parents=True, exist_ok=True)
        
        extension_data = {
            'metadata': {
                'name': name,
                'type': 'overlay',
                'extends': extends
            },
            'configuration': config
        }
        
        output_file = overlay_config_dir / f"{name}.yaml"
        self._save_yaml(output_file, extension_data)
        print(f"âœ… å‰µå»º overlay æ“´å±•: {output_file}")
        
        return output_file
    
    def synthesize_active(self):
        """åˆæˆ active è¦–åœ–"""
        print("ğŸ”„ åˆæˆ active è¦–åœ–...")
        
        # å‰µå»º active ç›®éŒ„
        self.active_path.mkdir(parents=True, exist_ok=True)
        
        # åˆä½µ baseline å’Œ overlay é…ç½®
        baseline_configs = list((self.baseline_path / "config").glob("*.yaml"))
        
        for baseline_file in baseline_configs:
            baseline_data = self._load_yaml(baseline_file)
            
            # æª¢æŸ¥æ˜¯å¦æœ‰å°æ‡‰çš„ overlay
            overlay_file = self.overlay_path / "config" / baseline_file.name
            if overlay_file.exists():
                overlay_data = self._load_yaml(overlay_file)
                # ç°¡å–®åˆä½µ (æ·±åº¦åˆä½µéœ€è¦æ›´è¤‡é›œçš„é‚è¼¯)
                merged_data = {**baseline_data, **overlay_data}
            else:
                merged_data = baseline_data
            
            # ä¿å­˜åˆ° active
            active_file = self.active_path / baseline_file.name
            self._save_yaml(active_file, merged_data)
        
        print(f"âœ… Active è¦–åœ–å·²åˆæˆåˆ°: {self.active_path}")

def main():
    parser = argparse.ArgumentParser(
        description="Controlplane CLI - è®“é…ç½®çœŸæ­£å¯ç”¨",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  cp-cli status                    # é¡¯ç¤ºç‹€æ…‹
  cp-cli get metadata.version      # ç²å–é…ç½®å€¼
  cp-cli list modules              # åˆ—å‡ºæ¨¡çµ„
  cp-cli validate                  # é‹è¡Œé©—è­‰
  cp-cli check-name my-file.yaml   # æª¢æŸ¥åç¨±
  cp-cli synthesize                # åˆæˆ active è¦–åœ–
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='å¯ç”¨å‘½ä»¤')
    
    # status å‘½ä»¤
    subparsers.add_parser('status', help='é¡¯ç¤º controlplane ç‹€æ…‹')
    
    # get å‘½ä»¤
    get_parser = subparsers.add_parser('get', help='ç²å–é…ç½®å€¼')
    get_parser.add_argument('key', help='é…ç½®éµ (æ”¯æŒé»è™Ÿè·¯å¾‘)')
    get_parser.add_argument('--json', action='store_true', help='JSON æ ¼å¼è¼¸å‡º')
    
    # list å‘½ä»¤
    list_parser = subparsers.add_parser('list', help='åˆ—å‡ºè³‡æº')
    list_parser.add_argument('resource', choices=['modules', 'namespaces'], help='è³‡æºé¡å‹')
    list_parser.add_argument('--json', action='store_true', help='JSON æ ¼å¼è¼¸å‡º')
    
    # validate å‘½ä»¤
    validate_parser = subparsers.add_parser('validate', help='é‹è¡Œé©—è­‰')
    validate_parser.add_argument('--verbose', action='store_true', help='è©³ç´°è¼¸å‡º')
    
    # check-name å‘½ä»¤
    check_parser = subparsers.add_parser('check-name', help='æª¢æŸ¥åç¨±è¦ç¯„')
    check_parser.add_argument('name', help='è¦æª¢æŸ¥çš„åç¨±')
    check_parser.add_argument('--type', dest='name_type', default='file', choices=['file', 'directory', 'module'], help='åç¨±é¡å‹')
    
    # synthesize å‘½ä»¤
    subparsers.add_parser('synthesize', help='åˆæˆ active è¦–åœ–')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    cli = ControlplaneCLI()
    
    try:
        if args.command == 'status':
            cli.show_status()
            
        elif args.command == 'get':
            value = cli.get_config(args.key)
            if value is None:
                print(f"âŒ é…ç½®éµä¸å­˜åœ¨: {args.key}", file=sys.stderr)
                return 1
            
            if args.json:
                print(json.dumps(value, indent=2, ensure_ascii=False))
            else:
                print(value)
                
        elif args.command == 'list':
            if args.resource == 'modules':
                items = cli.list_modules()
            else:
                items = cli.list_namespaces()
            
            if args.json:
                print(json.dumps(items, indent=2, ensure_ascii=False))
            else:
                for item in items:
                    name = item.get('name', item.get('namespace', 'unknown'))
                    print(f"  â€¢ {name}")
                    
        elif args.command == 'validate':
            success = cli.validate(verbose=args.verbose)
            return 0 if success else 1
            
        elif args.command == 'check-name':
            is_valid = cli.check_name(args.name, name_type=args.name_type)
            if is_valid:
                print(f"âœ… åç¨±ç¬¦åˆè¦ç¯„: {args.name}")
                return 0
            else:
                print(f"âŒ åç¨±ä¸ç¬¦åˆè¦ç¯„: {args.name}", file=sys.stderr)
                return 1
                
        elif args.command == 'synthesize':
            cli.synthesize_active()
            
    except Exception as e:
        print(f"âŒ éŒ¯èª¤: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1
    
    return 0

if __name__ == '__main__':
    sys.exit(main())
