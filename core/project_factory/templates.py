"""
Template Engine - 模板引擎

Jinja2-based template rendering system for project generation.
基於 Jinja2 的模板渲染系統。
"""

import logging
from pathlib import Path
from typing import Dict, Any, Optional, List
from jinja2 import Environment, FileSystemLoader, Template, select_autoescape

logger = logging.getLogger(__name__)


class TemplateEngine:
    """
    Template rendering engine for project generation.

    專案生成的模板渲染引擎。

    Uses Jinja2 for flexible template rendering with custom filters
    and functions.

    使用 Jinja2 進行靈活的模板渲染，支持自定義過濾器和函數。
    """

    def __init__(self, template_dir: Path):
        """
        Initialize template engine.

        Args:
            template_dir: Directory containing template files
        """
        self.template_dir = template_dir
        self.template_dir.mkdir(parents=True, exist_ok=True)

        self.env = Environment(
            loader=FileSystemLoader(str(template_dir)),
            autoescape=select_autoescape(['html', 'xml']),
            trim_blocks=True,
            lstrip_blocks=True,
        )

        # Register custom filters
        self._register_filters()

        logger.info(f"TemplateEngine initialized with dir: {template_dir}")

    def _register_filters(self):
        """Register custom Jinja2 filters."""

        def to_snake_case(s: str) -> str:
            """Convert string to snake_case."""
            return s.replace('-', '_').replace(' ', '_').lower()

        def to_kebab_case(s: str) -> str:
            """Convert string to kebab-case."""
            return s.replace('_', '-').replace(' ', '-').lower()

        def to_pascal_case(s: str) -> str:
            """Convert string to PascalCase."""
            return ''.join(word.capitalize() for word in s.replace('-', '_').split('_'))

        def to_camel_case(s: str) -> str:
            """Convert string to camelCase."""
            pascal = to_pascal_case(s)
            return pascal[0].lower() + pascal[1:] if pascal else ''

        self.env.filters['snake_case'] = to_snake_case
        self.env.filters['kebab_case'] = to_kebab_case
        self.env.filters['pascal_case'] = to_pascal_case
        self.env.filters['camel_case'] = to_camel_case

    def render(self, template_path: str, context: Dict[str, Any]) -> str:
        """
        Render a template with given context.

        使用給定上下文渲染模板。

        Args:
            template_path: Path to template file (relative to template_dir)
            context: Template variables

        Returns:
            str: Rendered content

        Example:
            >>> engine = TemplateEngine(Path("./templates"))
            >>> content = engine.render("python/main.py.j2", {
            ...     "package_name": "my_service",
            ...     "framework": "fastapi"
            ... })
        """
        try:
            template = self.env.get_template(template_path)
            return template.render(**context)
        except Exception as e:
            logger.error(f"Failed to render template {template_path}: {e}")
            # Return fallback template
            return self._get_fallback_template(template_path, context)

    def render_string(self, template_string: str, context: Dict[str, Any]) -> str:
        """
        Render a template string directly.

        直接渲染模板字符串。

        Args:
            template_string: Template content as string
            context: Template variables

        Returns:
            str: Rendered content
        """
        template = Template(template_string)
        return template.render(**context)

    def _get_fallback_template(self, template_path: str, context: Dict[str, Any]) -> str:
        """
        Get fallback content when template is missing.

        當模板缺失時獲取後備內容。
        """
        logger.warning(f"Using fallback for {template_path}")

        # Basic fallback based on file extension
        if template_path.endswith('.md.j2'):
            return f"# {context.get('project_name', 'Project')}\n\nGenerated by SynergyMesh Project Factory\n"
        elif template_path.endswith('.py.j2'):
            return f'"""{context.get("description", "Auto-generated module")}"""\n\n# TODO: Implement\n'
        elif template_path.endswith('.yaml.j2') or template_path.endswith('.yml.j2'):
            return f"# Auto-generated configuration\n# Project: {context.get('project_name', 'unknown')}\n"
        else:
            return f"# Auto-generated file\n# Template: {template_path}\n"

    def list_templates(self) -> Dict[str, List[str]]:
        """
        List all available templates organized by category.

        列出所有可用模板，按類別組織。

        Returns:
            Dict mapping categories to template lists
        """
        templates: Dict[str, List[str]] = {}

        if not self.template_dir.exists():
            return templates

        for template_file in self.template_dir.rglob("*.j2"):
            relative_path = template_file.relative_to(self.template_dir)
            category = str(relative_path.parts[0]) if relative_path.parts else "uncategorized"

            if category not in templates:
                templates[category] = []

            templates[category].append(str(relative_path))

        return templates

    def get_template_info(self, template_name: str) -> Optional[Dict[str, Any]]:
        """
        Get information about a specific template.

        獲取特定模板的資訊。

        Args:
            template_name: Name of template

        Returns:
            Dict containing template info, or None if not found
        """
        template_path = self.template_dir / template_name

        if not template_path.exists():
            return None

        return {
            "name": template_name,
            "path": str(template_path),
            "size": template_path.stat().st_size,
            "exists": True,
        }


class TemplateBuilder:
    """
    Builder for creating custom templates programmatically.

    用於以編程方式創建自定義模板的構建器。

    Example:
        >>> builder = TemplateBuilder()
        >>> builder.add_file(
        ...     "src/{{package_name}}/main.py",
        ...     'Main module content'
        ... )
        >>> builder.save(Path("./custom-template"))
    """

    def __init__(self):
        self.files: Dict[str, str] = {}

    def add_file(self, path: str, content: str) -> 'TemplateBuilder':
        """
        Add a file to the template.

        添加文件到模板。

        Args:
            path: File path (may contain Jinja2 variables)
            content: File content (may contain Jinja2 templates)

        Returns:
            self for chaining
        """
        self.files[path] = content
        return self

    def save(self, output_dir: Path) -> None:
        """
        Save template to directory.

        保存模板到目錄。

        Args:
            output_dir: Target directory
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        for file_path, content in self.files.items():
            full_path = output_dir / file_path
            full_path.parent.mkdir(parents=True, exist_ok=True)

            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)

        logger.info(f"Template saved to {output_dir}")

    def register(self, name: str) -> None:
        """
        Register template with the system.

        註冊模板到系統。

        Args:
            name: Template name
        """
        # TODO: Implement template registration
        logger.info(f"Template '{name}' registered")
