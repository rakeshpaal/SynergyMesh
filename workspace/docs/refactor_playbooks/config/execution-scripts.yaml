# ═══════════════════════════════════════════════════════════════════════════════
#                    Execution Scripts - 執行腳本配置
#                    重構引擎執行腳本架構與模板
# ═══════════════════════════════════════════════════════════════════════════════
#
# Version: 1.0.0
# Updated: 2025-12-08
# Purpose: 定義重構執行腳本的架構與使用方式
#
# ═══════════════════════════════════════════════════════════════════════════════

version: "1.0.0"
name: "ExecutionScripts"
description: "重構引擎執行腳本 - 自動化執行重構計畫"

# ============================================================================
# 腳本架構
# ============================================================================
scripts:
  # ─────────────────────────────────────────────────────────────────────────
  # 主執行腳本
  # ─────────────────────────────────────────────────────────────────────────
  main_executor:
    name: "refactor_engine.py"
    description: "重構引擎主執行腳本"
    location: "tools/refactor_engine.py"

    usage: |
      # 分析模式 - 生成分析報告
      python tools/refactor_engine.py analyze --target docs/refactor_playbooks

      # 規劃模式 - 生成執行計畫
      python tools/refactor_engine.py plan --target docs/refactor_playbooks --output plan.yaml

      # 執行模式 - 執行重構 (dry-run)
      python tools/refactor_engine.py execute --plan plan.yaml --dry-run

      # 執行模式 - 實際執行
      python tools/refactor_engine.py execute --plan plan.yaml --confirm

    commands:
      analyze:
        description: "分析目標目錄，生成分析報告"
        options:
          - "--target: 目標目錄路徑"
          - "--output: 輸出報告路徑"
          - "--format: 輸出格式 (md|yaml|json)"

      plan:
        description: "根據分析結果生成執行計畫"
        options:
          - "--target: 目標目錄"
          - "--output: 計畫輸出路徑"
          - "--priority: 優先級篩選 (P1|P2|P3|all)"

      execute:
        description: "執行重構計畫"
        options:
          - "--plan: 計畫檔案路徑"
          - "--dry-run: 模擬執行"
          - "--confirm: 確認執行"
          - "--phase: 指定階段 (1-9)"

      validate:
        description: "驗證執行結果"
        options:
          - "--target: 目標目錄"
          - "--report: 生成驗證報告"

      rollback:
        description: "回滾到之前的狀態"
        options:
          - "--checkpoint: 檢查點 ID"
          - "--steps: 回滾步數"

  # ─────────────────────────────────────────────────────────────────────────
  # 暫存區處理腳本
  # ─────────────────────────────────────────────────────────────────────────
  scratch_processor:
    name: "process_legacy_scratch.py"
    description: "處理 _legacy_scratch 暫存區的舊資產"
    location: "tools/process_legacy_scratch.py"

    usage: |
      # 掃描暫存區
      python tools/process_legacy_scratch.py scan

      # 分析單一資產
      python tools/process_legacy_scratch.py analyze --asset axiom_complete_architecture.txt

      # 生成決策報告
      python tools/process_legacy_scratch.py decide --asset axiom_complete_architecture.txt

      # 批量處理
      python tools/process_legacy_scratch.py batch --all

    commands:
      scan:
        description: "掃描暫存區中的所有資產"
        output: "asset_inventory.yaml"

      analyze:
        description: "分析單一資產"
        options:
          - "--asset: 資產檔案名"
          - "--deep: 深度分析"

      decide:
        description: "生成位置決策報告"
        options:
          - "--asset: 資產檔案名"
          - "--output: 輸出路徑"

      batch:
        description: "批量處理所有資產"
        options:
          - "--all: 處理所有"
          - "--filter: 過濾條件"

  # ─────────────────────────────────────────────────────────────────────────
  # 集成執行腳本
  # ─────────────────────────────────────────────────────────────────────────
  integration_executor:
    name: "execute_integration.py"
    description: "執行集成操作"
    location: "tools/execute_integration.py"

    usage: |
      # 執行單一集成
      python tools/execute_integration.py single --decision placement_decision.yaml

      # 批量集成
      python tools/execute_integration.py batch --decisions analyzed/

      # 子目錄重組
      python tools/execute_integration.py reorganize --target docs/refactor_playbooks

    commands:
      single:
        description: "執行單一資產的集成"
        options:
          - "--decision: 決策檔案"
          - "--dry-run: 模擬執行"

      batch:
        description: "批量執行集成"
        options:
          - "--decisions: 決策檔案目錄"
          - "--parallel: 並行數"

      reorganize:
        description: "整個子目錄重組"
        options:
          - "--target: 目標目錄"
          - "--plan: 重組計畫"

  # ─────────────────────────────────────────────────────────────────────────
  # 索引更新腳本
  # ─────────────────────────────────────────────────────────────────────────
  index_updater:
    name: "update_indexes.py"
    description: "更新各種索引檔案"
    location: "tools/update_indexes.py"

    usage: |
      # 更新所有索引
      python tools/update_indexes.py all

      # 只更新 index.yaml
      python tools/update_indexes.py machine

      # 只更新 INDEX.md
      python tools/update_indexes.py human

      # 驗證索引同步
      python tools/update_indexes.py verify

    commands:
      all:
        description: "更新所有索引"

      machine:
        description: "更新 index.yaml"

      human:
        description: "更新 INDEX.md"

      legacy:
        description: "更新 legacy_assets_index.yaml"

      verify:
        description: "驗證索引與實際結構同步"

  # ─────────────────────────────────────────────────────────────────────────
  # 驗證腳本
  # ─────────────────────────────────────────────────────────────────────────
  validator:
    name: "validate_structure.py"
    description: "驗證目錄結構正確性"
    location: "tools/validate_structure.py"

    usage: |
      # 完整驗證
      python tools/validate_structure.py full --target docs/refactor_playbooks

      # 結構驗證
      python tools/validate_structure.py structure

      # 引用驗證
      python tools/validate_structure.py references

      # 生成報告
      python tools/validate_structure.py report --output validation_report.md

    commands:
      full:
        description: "執行完整驗證"

      structure:
        description: "只驗證結構"

      references:
        description: "只驗證引用"

      naming:
        description: "只驗證命名"

      report:
        description: "生成驗證報告"

# ============================================================================
# 腳本模板 (Python)
# ============================================================================
script_templates:
  # 主執行腳本模板
  main_executor_template: |
    #!/usr/bin/env python3
    """
    Refactor Engine - 重構引擎主執行腳本

    Usage:
        python refactor_engine.py analyze --target <path>
        python refactor_engine.py plan --target <path> --output <file>
        python refactor_engine.py execute --plan <file> [--dry-run]
    """

    import argparse
    import yaml
    import os
    import sys
    from pathlib import Path
    from datetime import datetime
    from typing import Dict, List, Optional

    # ========================================================================
    # 配置載入
    # ========================================================================

    def load_config(config_path: str) -> Dict:
        """載入配置檔案"""
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)

    CONFIG_PATH = "docs/refactor_playbooks/config/refactor-engine-config.yaml"
    SCRATCH_CONFIG_PATH = "docs/refactor_playbooks/config/legacy-scratch-processor.yaml"
    INTEGRATION_CONFIG_PATH = "docs/refactor_playbooks/config/integration-processor.yaml"

    # ========================================================================
    # 分析器
    # ========================================================================

    class DirectoryAnalyzer:
        """目錄分析器"""

        def __init__(self, target_path: str):
            self.target = Path(target_path)
            self.config = load_config(CONFIG_PATH)

        def analyze(self) -> Dict:
            """執行完整分析"""
            return {
                "overview": self._analyze_overview(),
                "problems": self._identify_problems(),
                "structure": self._analyze_structure(),
                "dependencies": self._analyze_dependencies(),
            }

        def _analyze_overview(self) -> Dict:
            """分析目錄概覽"""
            files = list(self.target.rglob("*"))
            return {
                "total_files": len([f for f in files if f.is_file()]),
                "total_directories": len([f for f in files if f.is_dir()]),
                "max_depth": self._calculate_max_depth(),
                "file_types": self._count_file_types(),
            }

        def _identify_problems(self) -> List[Dict]:
            """識別問題"""
            problems = []
            # TODO: 實作問題識別邏輯
            return problems

        def _analyze_structure(self) -> Dict:
            """分析結構"""
            # TODO: 實作結構分析
            return {}

        def _analyze_dependencies(self) -> Dict:
            """分析依賴"""
            # TODO: 實作依賴分析
            return {}

        def _calculate_max_depth(self) -> int:
            """計算最大深度"""
            max_depth = 0
            for path in self.target.rglob("*"):
                depth = len(path.relative_to(self.target).parts)
                max_depth = max(max_depth, depth)
            return max_depth

        def _count_file_types(self) -> Dict[str, int]:
            """統計檔案類型"""
            counts = {}
            for file in self.target.rglob("*"):
                if file.is_file():
                    ext = file.suffix or "no_extension"
                    counts[ext] = counts.get(ext, 0) + 1
            return counts

    # ========================================================================
    # 計畫生成器
    # ========================================================================

    class PlanGenerator:
        """執行計畫生成器"""

        def __init__(self, analysis: Dict):
            self.analysis = analysis
            self.config = load_config(CONFIG_PATH)

        def generate(self) -> Dict:
            """生成執行計畫"""
            return {
                "metadata": {
                    "generated_at": datetime.now().isoformat(),
                    "version": "1.0.0",
                },
                "phases": self._generate_phases(),
                "validation": self._generate_validation_plan(),
            }

        def _generate_phases(self) -> List[Dict]:
            """生成各階段計畫"""
            phases = []
            # TODO: 根據分析結果生成階段
            return phases

        def _generate_validation_plan(self) -> Dict:
            """生成驗證計畫"""
            return {
                "structure_checks": [],
                "reference_checks": [],
                "quality_checks": [],
            }

    # ========================================================================
    # 執行器
    # ========================================================================

    class Executor:
        """重構執行器"""

        def __init__(self, plan: Dict, dry_run: bool = True):
            self.plan = plan
            self.dry_run = dry_run
            self.config = load_config(CONFIG_PATH)
            self.executed_steps = []

        def execute(self) -> Dict:
            """執行計畫"""
            results = {
                "success": True,
                "executed": [],
                "failed": [],
                "skipped": [],
            }

            for phase in self.plan.get("phases", []):
                phase_result = self._execute_phase(phase)
                results["executed"].extend(phase_result["executed"])
                results["failed"].extend(phase_result["failed"])

                if phase_result["failed"]:
                    results["success"] = False
                    break

            return results

        def _execute_phase(self, phase: Dict) -> Dict:
            """執行單一階段"""
            result = {"executed": [], "failed": []}

            for step in phase.get("steps", []):
                if self.dry_run:
                    print(f"[DRY-RUN] Would execute: {step}")
                    result["executed"].append(step)
                else:
                    try:
                        self._execute_step(step)
                        result["executed"].append(step)
                    except Exception as e:
                        result["failed"].append({"step": step, "error": str(e)})

            return result

        def _execute_step(self, step: Dict):
            """執行單一步驟"""
            operation = step.get("operation")
            # TODO: 實作各種操作
            pass

    # ========================================================================
    # CLI 入口
    # ========================================================================

    def main():
        parser = argparse.ArgumentParser(
            description="Refactor Engine - 智能重構引擎"
        )

        subparsers = parser.add_subparsers(dest="command", help="可用命令")

        # analyze 命令
        analyze_parser = subparsers.add_parser("analyze", help="分析目標目錄")
        analyze_parser.add_argument("--target", required=True, help="目標目錄")
        analyze_parser.add_argument("--output", help="輸出檔案")
        analyze_parser.add_argument("--format", default="yaml", help="輸出格式")

        # plan 命令
        plan_parser = subparsers.add_parser("plan", help="生成執行計畫")
        plan_parser.add_argument("--target", required=True, help="目標目錄")
        plan_parser.add_argument("--output", required=True, help="計畫輸出路徑")
        plan_parser.add_argument("--priority", default="all", help="優先級篩選")

        # execute 命令
        execute_parser = subparsers.add_parser("execute", help="執行重構")
        execute_parser.add_argument("--plan", required=True, help="計畫檔案")
        execute_parser.add_argument("--dry-run", action="store_true", help="模擬執行")
        execute_parser.add_argument("--confirm", action="store_true", help="確認執行")
        execute_parser.add_argument("--phase", type=int, help="指定階段")

        # validate 命令
        validate_parser = subparsers.add_parser("validate", help="驗證結果")
        validate_parser.add_argument("--target", required=True, help="目標目錄")
        validate_parser.add_argument("--report", action="store_true", help="生成報告")

        args = parser.parse_args()

        if args.command == "analyze":
            analyzer = DirectoryAnalyzer(args.target)
            result = analyzer.analyze()

            if args.output:
                with open(args.output, 'w', encoding='utf-8') as f:
                    if args.format == "yaml":
                        yaml.dump(result, f, allow_unicode=True, default_flow_style=False)
                    else:
                        import json
                        json.dump(result, f, indent=2, ensure_ascii=False)
            else:
                print(yaml.dump(result, allow_unicode=True, default_flow_style=False))

        elif args.command == "plan":
            analyzer = DirectoryAnalyzer(args.target)
            analysis = analyzer.analyze()
            generator = PlanGenerator(analysis)
            plan = generator.generate()

            with open(args.output, 'w', encoding='utf-8') as f:
                yaml.dump(plan, f, allow_unicode=True, default_flow_style=False)
            print(f"計畫已生成: {args.output}")

        elif args.command == "execute":
            with open(args.plan, 'r', encoding='utf-8') as f:
                plan = yaml.safe_load(f)

            dry_run = args.dry_run or not args.confirm
            executor = Executor(plan, dry_run=dry_run)
            result = executor.execute()

            if result["success"]:
                print("✅ 執行成功")
            else:
                print("❌ 執行失敗")
                for fail in result["failed"]:
                    print(f"  - {fail}")

        elif args.command == "validate":
            # TODO: 實作驗證邏輯
            print(f"驗證 {args.target}...")

        else:
            parser.print_help()

    if __name__ == "__main__":
        main()

# ============================================================================
# 輔助腳本配置
# ============================================================================
helper_scripts:
  # 快速分析腳本
  quick_analyze:
    name: "quick_analyze.sh"
    content: |
      #!/bin/bash
      # 快速分析 refactor_playbooks 目錄

      TARGET="${1:-docs/refactor_playbooks}"
      OUTPUT="${2:-analysis_report.yaml}"

      python tools/refactor_engine.py analyze \
        --target "$TARGET" \
        --output "$OUTPUT" \
        --format yaml

      echo "分析完成: $OUTPUT"

  # 批量處理腳本
  batch_process:
    name: "batch_process.sh"
    content: |
      #!/bin/bash
      # 批量處理 _legacy_scratch 中的所有資產

      SCRATCH_DIR="docs/refactor_playbooks/_legacy_scratch"
      OUTPUT_DIR="docs/refactor_playbooks/_legacy_scratch/analyzed"

      mkdir -p "$OUTPUT_DIR"

      for file in "$SCRATCH_DIR"/*; do
        if [ -f "$file" ]; then
          filename=$(basename "$file")
          echo "處理: $filename"
          python tools/process_legacy_scratch.py analyze \
            --asset "$filename" \
            --output "$OUTPUT_DIR/${filename%.}_decision.yaml"
        fi
      done

      echo "批量處理完成"

  # 驗證腳本
  validate_all:
    name: "validate_all.sh"
    content: |
      #!/bin/bash
      # 完整驗證 refactor_playbooks 結構

      TARGET="docs/refactor_playbooks"

      echo "=== 結構驗證 ==="
      python tools/validate_structure.py structure --target "$TARGET"

      echo ""
      echo "=== 引用驗證 ==="
      python tools/validate_structure.py references --target "$TARGET"

      echo ""
      echo "=== 索引驗證 ==="
      python tools/update_indexes.py verify

      echo ""
      echo "驗證完成"

# ============================================================================
# 使用指南
# ============================================================================
usage_guide:
  title: "重構引擎使用指南"

  quick_start: |
    ## 快速開始

    1. 分析目錄：
       ```bash
       python tools/refactor_engine.py analyze --target docs/refactor_playbooks
       ```

    2. 生成計畫：
       ```bash
       python tools/refactor_engine.py plan --target docs/refactor_playbooks --output plan.yaml
       ```

    3. 模擬執行：
       ```bash
       python tools/refactor_engine.py execute --plan plan.yaml --dry-run
       ```

    4. 實際執行：
       ```bash
       python tools/refactor_engine.py execute --plan plan.yaml --confirm
       ```

  workflow: |
    ## 完整工作流程

    ### 第一輪：分析與規劃
    1. 將舊資產放入 `_legacy_scratch/intake/`
    2. 執行掃描：`python tools/process_legacy_scratch.py scan`
    3. 分析資產：`python tools/process_legacy_scratch.py analyze --all`
    4. 生成決策：`python tools/process_legacy_scratch.py decide --all`
    5. 審查決策報告

    ### 第二輪：執行與驗證
    1. 根據決策報告生成執行計畫
    2. 執行 dry-run 確認無誤
    3. 執行實際重構
    4. 更新所有索引
    5. 執行完整驗證
    6. 生成完成報告
