"""
漏洞掃描器 - Vulnerability Scanner
掃描依賴項的已知安全漏洞
"""

import logging
import uuid
from dataclasses import dataclass

from ..models.dependency import Dependency, Ecosystem
from ..models.vulnerability import (
    Vulnerability,
    VulnerabilityScanResult,
    VulnerabilitySeverity,
    VulnerabilitySource,
)

logger = logging.getLogger(__name__)


@dataclass
class ScanConfig:
    """掃描配置"""
    sources: list[VulnerabilitySource]
    severity_threshold: VulnerabilitySeverity = VulnerabilitySeverity.MEDIUM
    include_dev_dependencies: bool = True
    timeout_seconds: int = 30


class VulnerabilityScanner:
    """
    漏洞掃描器
    
    整合多個漏洞數據源進行依賴項安全掃描：
    - NVD (美國國家漏洞數據庫)
    - GHSA (GitHub Security Advisories)
    - OSV (Open Source Vulnerabilities)
    """

    def __init__(self, config: ScanConfig | None = None):
        """
        初始化漏洞掃描器
        
        Args:
            config: 掃描配置，如未提供則使用默認配置
        """
        self.config = config or ScanConfig(
            sources=[
                VulnerabilitySource.NVD,
                VulnerabilitySource.GHSA,
                VulnerabilitySource.OSV
            ]
        )
        logger.info(f"漏洞掃描器初始化完成，數據源: {[s.value for s in self.config.sources]}")

    async def scan(
        self,
        dependencies: list[Dependency]
    ) -> VulnerabilityScanResult:
        """
        掃描依賴項列表中的漏洞
        
        Args:
            dependencies: 待掃描的依賴項列表
            
        Returns:
            漏洞掃描結果
        """
        scan_id = f"scan-{uuid.uuid4().hex[:8]}"
        result = VulnerabilityScanResult(scan_id=scan_id)

        logger.info(f"開始漏洞掃描 [{scan_id}]: {len(dependencies)} 個依賴項")

        # 追蹤已掃描的套件避免重複
        scanned: set[str] = set()

        for dep in dependencies:
            package_key = f"{dep.ecosystem.value}:{dep.name}@{dep.current_version}"

            if package_key in scanned:
                continue
            scanned.add(package_key)

            # 掃描每個數據源
            vulnerabilities = await self._scan_package(
                dep.name,
                dep.current_version,
                dep.ecosystem
            )

            for vuln in vulnerabilities:
                # 檢查是否符合嚴重程度閾值
                if self._meets_threshold(vuln.severity):
                    result.add_vulnerability(vuln)
                    dep.has_vulnerability = True
                    dep.vulnerability_count += 1

        logger.info(
            f"掃描完成 [{scan_id}]: 發現 {result.total_count} 個漏洞 "
            f"(嚴重: {result.critical_count}, 高危: {result.high_count})"
        )

        return result

    async def _scan_package(
        self,
        package_name: str,
        version: str,
        ecosystem: Ecosystem
    ) -> list[Vulnerability]:
        """
        掃描單個套件的漏洞
        
        Args:
            package_name: 套件名稱
            version: 版本號
            ecosystem: 生態系統
            
        Returns:
            發現的漏洞列表
        """
        vulnerabilities = []

        for source in self.config.sources:
            try:
                source_vulns = await self._query_source(
                    source,
                    package_name,
                    version,
                    ecosystem
                )
                vulnerabilities.extend(source_vulns)
            except Exception as e:
                logger.warning(f"查詢 {source.value} 時發生錯誤: {e}")

        # 去重（同一漏洞可能在多個數據源中出現）
        unique_vulns = self._deduplicate(vulnerabilities)

        return unique_vulns

    async def _query_source(
        self,
        source: VulnerabilitySource,
        package_name: str,
        version: str,
        ecosystem: Ecosystem
    ) -> list[Vulnerability]:
        """
        查詢指定數據源
        
        Args:
            source: 數據源
            package_name: 套件名稱
            version: 版本號
            ecosystem: 生態系統
            
        Returns:
            漏洞列表
        """
        # 根據不同數據源調用對應的查詢方法
        # 注意：實際實現需要 HTTP 請求到各數據源 API

        if source == VulnerabilitySource.NVD:
            return await self._query_nvd(package_name, version, ecosystem)
        elif source == VulnerabilitySource.GHSA:
            return await self._query_ghsa(package_name, version, ecosystem)
        elif source == VulnerabilitySource.OSV:
            return await self._query_osv(package_name, version, ecosystem)

        return []

    async def _query_nvd(
        self,
        package_name: str,
        version: str,
        ecosystem: Ecosystem
    ) -> list[Vulnerability]:
        """
        查詢 NVD 數據庫
        
        實際實現需要發送請求到:
        https://services.nvd.nist.gov/rest/json/cves/2.0
        """
        logger.debug(f"查詢 NVD: {package_name}@{version}")
        # 框架實現，實際需要 HTTP 請求
        return []

    async def _query_ghsa(
        self,
        package_name: str,
        version: str,
        ecosystem: Ecosystem
    ) -> list[Vulnerability]:
        """
        查詢 GitHub Security Advisories
        
        實際實現需要使用 GitHub GraphQL API:
        https://api.github.com/graphql
        """
        logger.debug(f"查詢 GHSA: {package_name}@{version}")
        # 框架實現，實際需要 HTTP 請求
        return []

    async def _query_osv(
        self,
        package_name: str,
        version: str,
        ecosystem: Ecosystem
    ) -> list[Vulnerability]:
        """
        查詢 OSV 數據庫
        
        實際實現需要發送請求到:
        https://api.osv.dev/v1/query
        """
        logger.debug(f"查詢 OSV: {package_name}@{version}")
        # 框架實現，實際需要 HTTP 請求
        return []

    def _meets_threshold(self, severity: VulnerabilitySeverity) -> bool:
        """
        檢查漏洞是否達到嚴重程度閾值
        
        Args:
            severity: 漏洞嚴重程度
            
        Returns:
            是否達到閾值
        """
        severity_order = [
            VulnerabilitySeverity.LOW,
            VulnerabilitySeverity.MEDIUM,
            VulnerabilitySeverity.HIGH,
            VulnerabilitySeverity.CRITICAL
        ]

        try:
            threshold_index = severity_order.index(self.config.severity_threshold)
            severity_index = severity_order.index(severity)
            return severity_index >= threshold_index
        except ValueError:
            return True

    def _deduplicate(
        self,
        vulnerabilities: list[Vulnerability]
    ) -> list[Vulnerability]:
        """
        去除重複的漏洞
        
        Args:
            vulnerabilities: 漏洞列表
            
        Returns:
            去重後的漏洞列表
        """
        seen_ids: set[str] = set()
        unique = []

        for vuln in vulnerabilities:
            if vuln.id not in seen_ids:
                seen_ids.add(vuln.id)
                unique.append(vuln)

        return unique

    async def check_single(
        self,
        package_name: str,
        version: str,
        ecosystem: Ecosystem
    ) -> list[Vulnerability]:
        """
        檢查單個套件的漏洞
        
        便捷方法，用於快速檢查單個套件
        
        Args:
            package_name: 套件名稱
            version: 版本號
            ecosystem: 生態系統
            
        Returns:
            漏洞列表
        """
        return await self._scan_package(package_name, version, ecosystem)
