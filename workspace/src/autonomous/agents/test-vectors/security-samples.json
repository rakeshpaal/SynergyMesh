{
  "_description": "Security test vectors for code analysis demo. These contain INTENTIONAL vulnerabilities for testing security scanners.",
  "_warning": "DO NOT use this code in production. These are examples of insecure patterns.",
  "version": "1.0.0",
  "test_cases": [
    {
      "id": "eval-injection",
      "name": "Eval Injection Vulnerability",
      "category": "security",
      "severity": "critical",
      "cwe": "CWE-95",
      "description": "Demonstrates dangerous eval() usage that can lead to code injection",
      "vulnerable_code": "def process_user_data(user_input, password):\n    # Security issue: using eval\n    result = eval(user_input)\n    \n    # Security issue: hardcoded password\n    db_password = \"DEMO_PLACEHOLDER\"\n    \n    # Performance issue: nested loops\n    data = []\n    for i in range(100):\n        for j in range(100):\n            for k in range(100):\n                data.append(i * j * k)\n    \n    return result, data",
      "expected_issues": [
        { "type": "security", "pattern": "eval" },
        { "type": "security", "pattern": "hardcoded_password" },
        { "type": "performance", "pattern": "nested_loops" }
      ],
      "fixed_code": "import ast\n\ndef process_user_data(user_input: str, password: str) -> tuple:\n    # Safe alternative: use ast.literal_eval for safe evaluation\n    try:\n        result = ast.literal_eval(user_input)\n    except (ValueError, SyntaxError):\n        result = None\n    \n    # Use environment variables or secure vault for passwords\n    import os\n    db_password = os.environ.get('DB_PASSWORD', '')\n    \n    # Performance fix: use list comprehension or numpy\n    import itertools\n    data = [i * j * k for i, j, k in itertools.product(range(100), repeat=3)]\n    \n    return result, data"
    },
    {
      "id": "sql-injection",
      "name": "SQL Injection Vulnerability",
      "category": "security",
      "severity": "critical",
      "cwe": "CWE-89",
      "description": "Demonstrates SQL injection through string concatenation",
      "vulnerable_code": "def get_user(username):\n    query = \"SELECT * FROM users WHERE name = '\" + username + \"'\"\n    return db.execute(query)",
      "expected_issues": [{ "type": "security", "pattern": "sql_injection" }],
      "fixed_code": "def get_user(username: str):\n    query = \"SELECT * FROM users WHERE name = ?\"\n    return db.execute(query, (username,))"
    },
    {
      "id": "command-injection",
      "name": "Command Injection Vulnerability",
      "category": "security",
      "severity": "critical",
      "cwe": "CWE-78",
      "description": "Demonstrates OS command injection through shell=True",
      "vulnerable_code": "import subprocess\n\ndef run_command(user_cmd):\n    subprocess.run(user_cmd, shell=True)",
      "expected_issues": [{ "type": "security", "pattern": "command_injection" }],
      "fixed_code": "import subprocess\nimport shlex\n\ndef run_command(user_cmd: str) -> subprocess.CompletedProcess:\n    # Use shlex.split and avoid shell=True\n    args = shlex.split(user_cmd)\n    return subprocess.run(args, shell=False, capture_output=True, text=True)"
    }
  ],
  "performance_cases": [
    {
      "id": "fibonacci-recursive",
      "name": "Inefficient Fibonacci",
      "category": "performance",
      "description": "Naive recursive Fibonacci without memoization",
      "code": "def calculate_fibonacci(n):\n    if n <= 1:\n        return n\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)",
      "expected_issues": [{ "type": "performance", "pattern": "exponential_complexity" }]
    }
  ]
}
