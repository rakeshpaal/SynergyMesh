category: performance
fix_config:
  auto_apply: false
  benchmark_requirements:
    max_regression: 0.05
    min_improvement: 0.2
  create_backup: true
  generate_report: true
  require_review: true
  rollback_conditions:
  - test_failure: true
  - performance_regression: true
  - memory_increase: 0.2
  run_benchmarks: true
performance_benchmarks:
  cpu:
    max_usage: 0.8
    target_usage: 0.5
  memory:
    max_heap: 512
    max_rss: 1024
  response_time:
    p50: 100
    p95: 200
    p99: 500
  throughput:
    min: 1000
    target: 5000
priority: high
rules:
- description: 檢測並修復 N+1 查詢問題
  enabled: true
  expected_improvement: 80-95% 查詢時間減少
  fix_strategy:
    action: "# 使用批量查詢\noriginal:\n  for item in items:\n      related = db.query(Related).filter(Related.id\
      \ == item.id).first()\n\nreplacement:\n  item_ids = [item.id for item in items]\n\
      \  related_map = {r.id: r for r in db.query(Related).filter(Related.id.in_(item_ids)).all()}\n\
      \  for item in items:\n      related = related_map.get(item.id)\n"
    template: performance-batch-query
    type: batch_query
  id: PERF-001
  name: n-plus-one-query
  patterns:
  - example: "for item in items:\n    related = db.query(Related).filter(Related.id\
      \ == item.id).first()\n"
    type: loop_with_query
  severity: HIGH
  verification:
  - run_tests: true
  - performance_benchmark: true
  - query_count_check: true
- description: 優化嵌套循環和低效迭代
  enabled: true
  expected_improvement: O(n²) → O(n)
  fix_strategy:
    action: "# 使用哈希表或集合優化\noriginal:\n  for item in items:\n      for other in others:\n\
      \          if item.id == other.id:\n              process(item, other)\n\nreplacement:\n\
      \  others_map = {o.id: o for o in others}\n  for item in items:\n      if item.id\
      \ in others_map:\n          process(item, others_map[item.id])\n"
    template: performance-loop-optimize
    type: algorithm_optimization
  id: PERF-002
  name: inefficient-loop
  patterns:
  - complexity_threshold: 2
    type: nested_loop
  - type: linear_search_in_loop
  severity: MEDIUM
  verification:
  - run_tests: true
  - performance_benchmark: true
- description: 優化記憶體使用
  enabled: true
  expected_improvement: 記憶體使用減少 50-90%
  fix_strategy:
    action: "# 使用生成器或迭代器\noriginal:\n  results = [process(item) for item in large_dataset]\n\
      \nreplacement:\n  results = (process(item) for item in large_dataset)\n  # 或使用分批處理\n\
      \  for batch in chunks(large_dataset, 1000):\n      process_batch(batch)\n"
    template: performance-memory-optimize
    type: memory_efficient
  id: PERF-003
  name: memory-optimization
  patterns:
  - type: large_list_comprehension
  - type: unnecessary_copy
  - type: memory_leak
  severity: MEDIUM
  verification:
  - run_tests: true
  - memory_profiling: true
- description: 添加適當的緩存
  enabled: true
  expected_improvement: 計算時間減少 70-99%
  fix_strategy:
    action: "# 添加 LRU 緩存\noriginal:\n  def expensive_function(param):\n      # 昂貴的計算\n\
      \      return result\n\nreplacement:\n  from functools import lru_cache\n  \n\
      \  @lru_cache(maxsize=128)\n  def expensive_function(param):\n      # 昂貴的計算\n\
      \      return result\n"
    template: performance-cache
    type: add_caching
  id: PERF-004
  name: missing-cache
  patterns:
  - type: repeated_computation
  - type: expensive_function_call
  severity: MEDIUM
  verification:
  - run_tests: true
  - performance_benchmark: true
  - cache_hit_rate_check: true
- description: 優化數據庫查詢
  enabled: true
  expected_improvement: 查詢時間減少 60-95%
  fix_strategy:
    action: "# 優化查詢\noriginal:\n  results = db.query(Model).all()\n  filtered = [r\
      \ for r in results if r.status == 'active']\n\nreplacement:\n  results = db.query(Model).filter(Model.status\
      \ == 'active').all()\n"
    template: performance-query-optimize
    type: query_optimization
  id: PERF-005
  name: inefficient-query
  patterns:
  - type: missing_index
  - type: select_all
  - type: missing_join
  severity: HIGH
  verification:
  - run_tests: true
  - explain_analyze: true
  - performance_benchmark: true
- description: 識別並實現並行化機會
  enabled: true
  expected_improvement: 執行時間減少 50-90%
  fix_strategy:
    action: "# 使用並行處理\noriginal:\n  results = [fetch_data(url) for url in urls]\n\n\
      replacement:\n  from concurrent.futures import ThreadPoolExecutor\n  \n  with\
      \ ThreadPoolExecutor(max_workers=10) as executor:\n      results = list(executor.map(fetch_data,\
      \ urls))\n"
    template: performance-parallel
    type: add_parallelization
  id: PERF-006
  name: parallelization-opportunity
  patterns:
  - type: independent_operations
  - type: io_bound_loop
  severity: MEDIUM
  verification:
  - run_tests: true
  - performance_benchmark: true
  - thread_safety_check: true
version: 1.0.0
