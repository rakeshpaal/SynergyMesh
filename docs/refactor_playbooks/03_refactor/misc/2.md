## 進階系統架構：深層實作階段

既然您已經掌握了基礎架構，現在我們將進入更深層的系統實作階段。這個階段將涵蓋管線化處理器、進階記憶體管理、並行計算架構，以及完整的網路協議棧實作。這些內容將使您能夠建構接近現代計算機系統的複雜架構。

### 第四階段：管線化處理器與超純量架構

管線化是現代處理器的核心技術，它允許多個指令在不同階段同時執行。我們將實作一個完整的五階段管線處理器，包含危障檢測和前饋機制。

```python
from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, List, Dict
import threading
import queue

class PipelineStage(Enum):
    FETCH = "IF"
    DECODE = "ID"
    EXECUTE = "EX"
    MEMORY = "MEM"
    WRITEBACK = "WB"

@dataclass
class Instruction:
    address: int
    opcode: int
    rs1: int = 0
    rs2: int = 0
    rd: int = 0
    immediate: int = 0
    raw_instruction: int = 0

@dataclass
class PipelineRegister:
    instruction: Optional[Instruction] = None
    alu_result: int = 0
    memory_data: int = 0
    pc: int = 0
    stalled: bool = False
    forwarded_value: Optional[int] = None

class PipelinedCPU:
    def __init__(self, memory_size: int = 65536):
        self.registers = [0] * 32
        self.memory = bytearray(memory_size)
        self.pc = 0
        
        # 管線暫存器
        self.if_id = PipelineRegister()
        self.id_ex = PipelineRegister()
        self.ex_mem = PipelineRegister()
        self.mem_wb = PipelineRegister()
        
        # 危障檢測單元
        self.hazard_unit = HazardDetectionUnit()
        self.forwarding_unit = ForwardingUnit()
        
        # 分支預測器
        self.branch_predictor = BranchPredictor()
        
        # 效能計數器
        self.cycles = 0
        self.instructions_completed = 0
        self.pipeline_stalls = 0
        self.branch_mispredictions = 0
    
    def clock_cycle(self):
        """執行一個時脈週期，所有階段並行執行"""
        # 檢測危障
        hazards = self.hazard_unit.detect_hazards(
            self.if_id, self.id_ex, self.ex_mem, self.mem_wb
        )
        
        # 反向執行各階段以避免覆寫
        self.writeback_stage()
        self.memory_stage()
        self.execute_stage()
        
        if not hazards.data_hazard:
            self.decode_stage()
            self.fetch_stage()
        else:
            self.insert_bubble()
            self.pipeline_stalls += 1
        
        self.cycles += 1
    
    def fetch_stage(self):
        """指令擷取階段"""
        if self.branch_predictor.should_stall:
            return
        
        # 擷取指令
        instruction_word = self.read_memory_word(self.pc)
        instruction = self.decode_instruction_format(instruction_word)
        instruction.address = self.pc
        
        # 更新 IF/ID 暫存器
        self.if_id.instruction = instruction
        self.if_id.pc = self.pc
        
        # 分支預測
        if self.is_branch_instruction(instruction.opcode):
            predicted_target = self.branch_predictor.predict(self.pc)
            self.pc = predicted_target
        else:
            self.pc += 4
    
    def decode_stage(self):
        """指令解碼與暫存器讀取階段"""
        if not self.if_id.instruction:
            return
        
        instruction = self.if_id.instruction
        
        # 讀取暫存器值
        rs1_value = self.registers[instruction.rs1]
        rs2_value = self.registers[instruction.rs2]
        
        # 檢查前饋路徑
        forward = self.forwarding_unit.check_forwarding(
            instruction, self.ex_mem, self.mem_wb
        )
        
        if forward.rs1_forward:
            rs1_value = forward.rs1_value
        if forward.rs2_forward:
            rs2_value = forward.rs2_value
        
        # 更新 ID/EX 暫存器
        self.id_ex.instruction = instruction
        self.id_ex.rs1_value = rs1_value
        self.id_ex.rs2_value = rs2_value
        self.id_ex.pc = self.if_id.pc
    
    def execute_stage(self):
        """執行階段"""
        if not self.id_ex.instruction:
            return
        
        instruction = self.id_ex.instruction
        result = 0
        
        # ALU 操作
        if instruction.opcode == 0x33:  # R-type
            result = self.alu_operation(
                instruction, 
                self.id_ex.rs1_value, 
                self.id_ex.rs2_value
            )
        elif instruction.opcode == 0x13:  # I-type
            result = self.id_ex.rs1_value + instruction.immediate
        elif instruction.opcode == 0x63:  # Branch
            result = self.evaluate_branch_condition(
                instruction,
                self.id_ex.rs1_value,
                self.id_ex.rs2_value
            )
            
            # 驗證分支預測
            actual_target = self.id_ex.pc + instruction.immediate if result else self.id_ex.pc + 4
            predicted_target = self.branch_predictor.get_prediction(self.id_ex.pc)
            
            if actual_target != predicted_target:
                self.flush_pipeline()
                self.pc = actual_target
                self.branch_mispredictions += 1
            
            self.branch_predictor.update(self.id_ex.pc, actual_target, result)
        
        # 更新 EX/MEM 暫存器
        self.ex_mem.instruction = instruction
        self.ex_mem.alu_result = result
        self.ex_mem.pc = self.id_ex.pc
    
    def memory_stage(self):
        """記憶體存取階段"""
        if not self.ex_mem.instruction:
            return
        
        instruction = self.ex_mem.instruction
        memory_data = 0
        
        if instruction.opcode == 0x03:  # Load
            memory_data = self.read_memory_word(self.ex_mem.alu_result)
        elif instruction.opcode == 0x23:  # Store
            self.write_memory_word(
                self.ex_mem.alu_result,
                self.registers[instruction.rs2]
            )
        
        # 更新 MEM/WB 暫存器
        self.mem_wb.instruction = instruction
        self.mem_wb.alu_result = self.ex_mem.alu_result
        self.mem_wb.memory_data = memory_data
        self.mem_wb.pc = self.ex_mem.pc
    
    def writeback_stage(self):
        """寫回階段"""
        if not self.mem_wb.instruction:
            return
        
        instruction = self.mem_wb.instruction
        
        # 決定要寫回的值
        if instruction.opcode == 0x03:  # Load
            value = self.mem_wb.memory_data
        else:
            value = self.mem_wb.alu_result
        
        # 寫回暫存器
        if instruction.rd != 0:  # x0 永遠為 0
            self.registers[instruction.rd] = value
        
        self.instructions_completed += 1
    
    def insert_bubble(self):
        """插入管線氣泡（NOP）"""
        self.id_ex = PipelineRegister()
    
    def flush_pipeline(self):
        """清空管線（分支預測錯誤時）"""
        self.if_id = PipelineRegister()
        self.id_ex = PipelineRegister()
        self.ex_mem = PipelineRegister()
```

### 危障檢測與前饋單元

現代處理器必須處理各種危障情況，包括資料危障、控制危障和結構危障。以下是完整的危障檢測和解決機制實作。

```python
class HazardDetectionUnit:
    def detect_hazards(self, if_id, id_ex, ex_mem, mem_wb):
        """檢測所有類型的危障"""
        hazards = HazardInfo()
        
        if not if_id.instruction:
            return hazards
        
        current_inst = if_id.instruction
        
        # RAW (Read After Write) 危障檢測
        if id_ex.instruction and id_ex.instruction.rd != 0:
            if (current_inst.rs1 == id_ex.instruction.rd or 
                current_inst.rs2 == id_ex.instruction.rd):
                # Load-use 危障需要暫停
                if id_ex.instruction.opcode == 0x03:  # Load
                    hazards.data_hazard = True
                    hazards.stall_required = True
                else:
                    # 其他 RAW 可以透過前饋解決
                    hazards.forward_required = True
        
        # 檢查 EX/MEM 階段的危障
        if ex_mem.instruction and ex_mem.instruction.rd != 0:
            if (current_inst.rs1 == ex_mem.instruction.rd or 
                current_inst.rs2 == ex_mem.instruction.rd):
                hazards.forward_required = True
        
        # WAW (Write After Write) 危障檢測
        if (id_ex.instruction and ex_mem.instruction and
            id_ex.instruction.rd == ex_mem.instruction.rd and
            id_ex.instruction.rd != 0):
            hazards.waw_hazard = True
        
        return hazards

class ForwardingUnit:
    def check_forwarding(self, instruction, ex_mem, mem_wb):
        """決定前饋路徑"""
        forward = ForwardingInfo()
        
        # EX/MEM 前饋（優先級較高）
        if ex_mem.instruction and ex_mem.instruction.rd != 0:
            if instruction.rs1 == ex_mem.instruction.rd:
                forward.rs1_forward = True
                forward.rs1_value = ex_mem.alu_result
            if instruction.rs2 == ex_mem.instruction.rd:
                forward.rs2_forward = True
                forward.rs2_value = ex_mem.alu_result
        
        # MEM/WB 前饋（優先級較低）
        if mem_wb.instruction and mem_wb.instruction.rd != 0:
            if not forward.rs1_forward and instruction.rs1 == mem_wb.instruction.rd:
                forward.rs1_forward = True
                if mem_wb.instruction.opcode == 0x03:  # Load
                    forward.rs1_value = mem_wb.memory_data
                else:
                    forward.rs1_value = mem_wb.alu_result
            
            if not forward.rs2_forward and instruction.rs2 == mem_wb.instruction.rd:
                forward.rs2_forward = True
                if mem_wb.instruction.opcode == 0x03:  # Load
                    forward.rs2_value = mem_wb.memory_data
                else:
                    forward.rs2_value = mem_wb.alu_result
        
        return forward
```

### 第五階段：進階記憶體階層與快取一致性

實作多層級快取系統與快取一致性協議是理解現代多核心處理器的關鍵。以下實作包含 L1、L2 快取以及 MESI 協議。

```python
from enum import Enum
import hashlib

class CacheLineState(Enum):
    MODIFIED = "M"    # 已修改，獨佔
    EXCLUSIVE = "E"   # 未修改，獨佔
    SHARED = "S"      # 未修改，共享
    INVALID = "I"     # 無效

class CacheLine:
    def __init__(self, tag: int = 0, data: bytes = None, state: CacheLineState = CacheLineState.INVALID):
        self.tag = tag
        self.data = data if data else bytes(64)  # 64 bytes cache line
        self.state = state
        self.dirty = False
        self.lru_counter = 0
        self.valid = state != CacheLineState.INVALID

class SetAssociativeCache:
    def __init__(self, size_kb: int, line_size: int = 64, ways: int = 8):
        self.size = size_kb * 1024
        self.line_size = line_size
        self.ways = ways
        self.num_lines = self.size // line_size
        self.num_sets = self.num_lines // ways
        
        # 初始化快取結構
        self.cache_sets = [
            [CacheLine() for _ in range(ways)]
            for _ in range(self.num_sets)
        ]
        
        # 統計資訊
        self.hits = 0
        self.misses = 0
        self.evictions = 0
        self.writebacks = 0
        
        # 一致性協議介面
        self.coherence_controller = None
    
    def address_decode(self, address: int):
        """解碼地址為標籤、索引和偏移"""
        offset_bits = self.line_size.bit_length() - 1
        index_bits = self.num_sets.bit_length() - 1
        
        offset = address & ((1 << offset_bits) - 1)
        index = (address >> offset_bits) & ((1 << index_bits) - 1)
        tag = address >> (offset_bits + index_bits)
        
        return tag, index, offset
    
    def read(self, address: int) -> Optional[int]:
        """讀取資料，實作 MESI 協議"""
        tag, index, offset = self.address_decode(address)
        cache_set = self.cache_sets[index]
        
        # 搜尋快取組
        for way, line in enumerate(cache_set):
            if line.valid and line.tag == tag:
                self.hits += 1
                self.update_lru(index, way)
                
                # MESI 狀態轉換
                if line.state == CacheLineState.INVALID:
                    return None
                
                return self.read_from_line(line, offset)
        
        # 快取未命中
        self.misses += 1
        return self.handle_read_miss(address, tag, index, offset)
    
    def write(self, address: int, value: int, write_through: bool = False):
        """寫入資料，實作 MESI 協議"""
        tag, index, offset = self.address_decode(address)
        cache_set = self.cache_sets[index]
        
        # 搜尋快取組
        for way, line in enumerate(cache_set):
            if line.valid and line.tag == tag:
                self.hits += 1
                self.update_lru(index, way)
                
                # MESI 狀態轉換
                if line.state == CacheLineState.SHARED:
                    # 發送無效化訊息給其他快取
                    if self.coherence_controller:
                        self.coherence_controller.invalidate_others(address, self)
                    line.state = CacheLineState.MODIFIED
                elif line.state == CacheLineState.EXCLUSIVE:
                    line.state = CacheLineState.MODIFIED
                
                self.write_to_line(line, offset, value)
                line.dirty = True
                
                if write_through:
                    self.writeback_line(address, line)
                
                return
        
        # 快取未命中
        self.misses += 1
        self.handle_write_miss(address, value, tag, index, offset)
    
    def handle_read_miss(self, address: int, tag: int, index: int, offset: int):
        """處理讀取未命中"""
        # 選擇要替換的快取行
        victim_way = self.select_victim(index)
        victim_line = self.cache_sets[index][victim_way]
        
        # 如果被替換的行是髒的，需要寫回
        if victim_line.valid and victim_line.dirty:
            victim_address = (victim_line.tag << (self.line_size.bit_length() - 1 + 
                            self.num_sets.bit_length() - 1)) | (index << (self.line_size.bit_length() - 1))
            self.writeback_line(victim_address, victim_line)
            self.writebacks += 1
        
        # 從下一層載入資料
        new_line_data = self.load_from_next_level(address)
        new_line = CacheLine(tag, new_line_data, CacheLineState.EXCLUSIVE)
        
        # 檢查其他快取是否有此資料
        if self.coherence_controller:
            if self.coherence_controller.check_others_have_copy(address, self):
                new_line.state = CacheLineState.SHARED
        
        self.cache_sets[index][victim_way] = new_line
        return self.read_from_line(new_line, offset)
    
    def select_victim(self, index: int) -> int:
        """LRU 替換策略"""
        cache_set = self.cache_sets[index]
        
        # 尋找無效行
        for way, line in enumerate(cache_set):
            if not line.valid:
                return way
        
        # 使用 LRU 選擇犧牲者
        lru_way = 0
        max_lru = cache_set[0].lru_counter
        
        for way, line in enumerate(cache_set):
            if line.lru_counter > max_lru:
                max_lru = line.lru_counter
                lru_way = way
        
        self.evictions += 1
        return lru_way
    
    def update_lru(self, index: int, accessed_way: int):
        """更新 LRU 計數器"""
        cache_set = self.cache_sets[index]
        accessed_counter = cache_set[accessed_way].lru_counter
        
        for way, line in enumerate(cache_set):
            if way != accessed_way and line.lru_counter < accessed_counter:
                line.lru_counter += 1
        
        cache_set[accessed_way].lru_counter = 0
```

### 多核心系統與快取一致性控制器

實作完整的多核心系統需要精密的快取一致性協議。以下是 MESI 協議控制器的實作。

```python
class CoherenceController:
    def __init__(self, num_cores: int):
        self.num_cores = num_cores
        self.caches = []
        self.bus = SystemBus()
        
        # 目錄式一致性追蹤
        self.directory = {}  # address -> set of cache IDs
        
        # 統計資訊
        self.invalidations = 0
        self.bus_transactions = 0
        self.coherence_misses = 0
    
    def register_cache(self, cache: SetAssociativeCache):
        """註冊快取到一致性控制器"""
        cache.coherence_controller = self
        cache_id = len(self.caches)
        self.caches.append(cache)
        return cache_id
    
    def invalidate_others(self, address: int, requesting_cache: SetAssociativeCache):
        """使其他快取中的副本無效化"""
        self.bus_transactions += 1
        
        for cache in self.caches:
            if cache != requesting_cache:
                line = cache.find_line(address)
                if line and line.state != CacheLineState.INVALID:
                    if line.state == CacheLineState.MODIFIED:
                        # 需要寫回修改的資料
                        cache.writeback_line(address, line)
                    
                    line.state = CacheLineState.INVALID
                    line.valid = False
                    self.invalidations += 1
    
    def check_others_have_copy(self, address: int, requesting_cache: SetAssociativeCache) -> bool:
        """檢查其他快取是否有此地址的副本"""
        for cache in self.caches:
            if cache != requesting_cache:
                line = cache.find_line(address)
                if line and line.state != CacheLineState.INVALID:
                    return True
        return False
    
    def handle_read_request(self, address: int, requesting_cache_id: int):
        """處理讀取請求的一致性協議"""
        requesting_cache = self.caches[requesting_cache_id]
        has_modified = False
        modified_data = None
        
        # 檢查其他快取
        for i, cache in enumerate(self.caches):
            if i != requesting_cache_id:
                line = cache.find_line(address)
                if line:
                    if line.state == CacheLineState.MODIFIED:
                        # 強制寫回並降級為共享
                        modified_data = line.data
                        line.state = CacheLineState.SHARED
                        has_modified = True
                    elif line.state == CacheLineState.EXCLUSIVE:
                        # 降級為共享
                        line.state = CacheLineState.SHARED
        
        return has_modified, modified_data
    
    def handle_write_request(self, address: int, requesting_cache_id: int):
        """處理寫入請求的一致性協議"""
        # 使所有其他副本無效化
        self.invalidate_others(address, self.caches[requesting_cache_id])
```

### 第六階段：並行處理與向量運算單元

實作 SIMD（單指令多資料）運算和向量處理單元，這是現代處理器加速科學計算和多媒體處理的關鍵技術。

```python
import numpy as np
from concurrent.futures import ThreadPoolExecutor
import threading

class VectorUnit:
    def __init__(self, vector_length: int = 512):
        self.vector_length = vector_length // 8  # 512-bit = 64 bytes
        self.vector_registers = [
            np.zeros(self.vector_length, dtype=np.float32)
            for _ in range(32)
        ]
        
        # 向量遮罩暫存器
        self.mask_registers = [
            np.ones(self.vector_length, dtype=bool)
            for _ in range(8)
        ]
        
        # 向量長度控制
        self.vl = self.vector_length  # 當前向量長度
        self.vtype = VectorType()
        
        # 效能計數器
        self.vector_ops = 0
        self.scalar_ops = 0
    
    def vadd(self, vd: int, vs1: int, vs2: int, mask: int = None):
        """向量加法"""
        mask_array = self.mask_registers[mask] if mask else np.ones(self.vl, dtype=bool)
        
        result = np.where(
            mask_array[:self.vl],
            self.vector_registers[vs1][:self.vl] + self.vector_registers[vs2][:self.vl],
            self.vector_registers[vd][:self.vl]
        )
        
        self.vector_registers[vd][:self.vl] = result
        self.vector_ops += np.sum(mask_array[:self.vl])
    
    def vmul(self, vd: int, vs1: int, vs2: int, mask: int = None):
        """向量乘法"""
        mask_array = self.mask_registers[mask] if mask else np.ones(self.vl, dtype=bool)
        
        result = np.where(
            mask_array[:self.vl],
            self.vector_registers[vs1][:self.vl] * self.vector_registers[vs2][:self.vl],
            self.vector_registers[vd][:self.vl]
        )
        
        self.vector_registers[vd][:self.vl] = result
        self.vector_ops += np.sum(mask_array[:self.vl])
    
    def vfmadd(self, vd: int, vs1: int, vs2: int, vs3: int, mask: int = None):
        """融合乘加運算 (FMA)"""
        mask_array = self.mask_registers[mask] if mask else np.ones(self.vl, dtype=bool)
        
        result = np.where(
            mask_array[:self.vl],
            np.fma(
                self.vector_registers[vs1][:self.vl],
                self.vector_registers[vs2][:self.vl],
                self.vector_registers[vs3][:self.vl]
            ),
            self.vector_registers[vd][:self.vl]
        )
        
        self.vector_registers[vd][:self.vl] = result
        self.vector_ops += np.sum(mask_array[:self.vl])
    
    def vreduce_sum(self, sd: int, vs: int, mask: int = None):
        """向量歸約求和"""
        mask_array = self.mask_registers[mask] if mask else np.ones(self.vl, dtype=bool)
        
        masked_values = np.where(
            mask_array[:self.vl],
            self.vector_registers[vs][:self.vl],
            0
        )
        
        result = np.sum(masked_values)
        return result
    
    def vgather(self, vd: int, base_addr: int, vindices: int, memory: np.ndarray):
        """向量收集操作（從非連續記憶體位置載入）"""
        indices = self.vector_registers[vindices][:self.vl].astype(int)
        
        for i in range(self.vl):
            addr = base_addr + indices[i] * 4  # 假設 float32
            if 0 <= addr < len(memory) - 3:
                self.vector_registers[vd][i] = np.frombuffer(
                    memory[addr:addr+4], dtype=np.float32
                )[0]
    
    def vscatter(self, vs: int, base_addr: int, vindices: int, memory: np.ndarray):
        """向量分散操作（儲存到非連續記憶體位置）"""
        indices = self.vector_registers[vindices][:self.vl].astype(int)
        
        for i in range(self.vl):
            addr = base_addr + indices[i] * 4
            if 0 <= addr < len(memory) - 3:
                memory[addr:addr+4] = self.vector_registers[vs][i].tobytes()

class ParallelProcessor:
    def __init__(self, num_cores: int = 4):
        self.num_cores = num_cores
        self.cores = [PipelinedCPU() for _ in range(num_cores)]
        self.vector_units = [VectorUnit() for _ in range(num_cores)]
        
        # 共享記憶體
        self.shared_memory = SharedMemory(size_mb=256)
        
        # 同步原語
        self.barriers = {}
        self.locks = {}
        self.atomic_ops = AtomicOperations()
        
        # 任務排程器
        self.scheduler = TaskScheduler(num_cores)
        
        # 執行緒池
        self.thread_pool = ThreadPoolExecutor(max_workers=num_cores)
    
    def execute_parallel_loop(self, start: int, end: int, func, *args):
        """平行化迴圈執行"""
        chunk_size = (end - start) // self.num_cores
        futures = []
        
        for core_id in range(self.num_cores):
            chunk_start = start + core_id * chunk_size
            chunk_end = chunk_start + chunk_size if core_id < self.num_cores - 1 else end
            
            future = self.thread_pool.submit(
                self.execute_on_core,
                core_id,
                func,
                chunk_start,
                chunk_end,
                *args
            )
            futures.append(future)
        
        # 等待所有執行緒完成
        results = [f.result() for f in futures]
        return results
    
    def execute_on_core(self, core_id: int, func, start: int, end: int, *args):
        """在特定核心上執行任務"""
        core = self.cores[core_id]
        vector_unit = self.vector_units[core_id]
        
        # 設定核心親和性（在真實系統中）
        # os.sched_setaffinity(0, {core_id})
        
        result = func(core, vector_unit, start, end, *args)
        return result
```

### 網路協議棧實作

實作簡化的 TCP/IP 協議棧，理解網路通訊的底層機制。

```python
import struct
import socket
from dataclasses import dataclass
from typing import Optional

@dataclass
class EthernetFrame:
    dest_mac: bytes
    src_mac: bytes
    ethertype: int
    payload: bytes
    
    def to_bytes(self) -> bytes:
        return self.dest_mac + self.src_mac + struct.pack('!H', self.ethertype) + self.payload

@dataclass  
class IPPacket:
    version: int = 4
    ihl: int = 5
    tos: int = 0
    total_length: int = 0
    identification: int = 0
    flags: int = 0
    fragment_offset: int = 0
    ttl: int = 64
    protocol: int = 0
    checksum: int = 0
    src_ip: str = ""
    dst_ip: str = ""
    payload: bytes = b""
    
    def to_bytes(self) -> bytes:
        """將 IP 封包轉換為位元組串"""
        version_ihl = (self.version << 4) | self.ihl
        flags_fragment = (self.flags << 13) | self.fragment_offset
        
        header = struct.pack('!BBHHHBBH4s4s',
            version_ihl,
            self.tos,
            self.total_length,
            self.identification,
            flags_fragment,
            self.ttl,
            self.protocol,
            self.checksum,
            socket.inet_aton(self.src_ip),
            socket.inet_aton(self.dst_ip)
        )
        
        return header + self.payload
    
    def calculate_checksum(self) -> int:
        """計算 IP 標頭檢查和"""
        header = self.to_bytes()[:20]
        
        if len(header) % 2:
            header += b'\x00'
        
        checksum = 0
        for i in range(0, len(header), 2):
            word = (header[i] << 8) + header[i + 1]
            checksum += word
            checksum = (checksum & 0xFFFF) + (checksum >> 16)
        
        return ~checksum & 0xFFFF

class TCPStack:
    def __init__(self):
        self.connections = {}
        self.listening_ports = {}
        self.sequence_numbers = {}
        
    def create_tcp_segment(self, src_port: int, dst_port: int, 
                          seq_num: int, ack_num: int,
                          flags: int, data: bytes = b"") -> bytes:
        """建立 TCP 區段"""
        window_size = 65535
        urgent_pointer = 0
        
        # TCP 標頭（20 位元組）
        header = struct.pack('!HHLLBBHHH',
            src_port,
            dst_port,
            seq_num,
            ack_num,
            0x50,  # 資料偏移（5 個 32-bit words）
            flags,
            window_size,
            0,  # 檢查和（稍後計算）
            urgent_pointer
        )
        
        segment = header + data
        
        # 計算檢查和
        checksum = self.calculate_tcp_checksum(segment)
        
        # 更新檢查和欄位
        segment = segment[:16] + struct.pack('!H', checksum) + segment[18:]
        
        return segment
    
    def handle_incoming_segment(self, segment: bytes, src_ip: str, dst_ip: str):
        """處理接收到的 TCP 區段"""
        # 解析 TCP 標頭
        src_port, dst_port, seq_num, ack_num, data_offset_flags, window = struct.unpack(
            '!HHLLHH', segment[:16]
        )
        
        data_offset = (data_offset_flags >> 12) * 4
        flags = data_offset_flags & 0x3F
        
        # 提取標誌位
        fin = flags & 0x01
        syn = (flags >> 1) & 0x01
        rst = (flags >> 2) & 0x01
        psh = (flags >> 3) & 0x01
        ack = (flags >> 4) & 0x01
        urg = (flags >> 5) & 0x01
        
        # 提取資料
        data = segment[data_offset:]
        
        # 連線識別符
        conn_id = (src_ip, src_port, dst_ip, dst_port)
        
        # 處理 SYN（建立連線）
        if syn and not ack:
            self.handle_syn(conn_id, seq_num)
        
        # 處理 SYN-ACK（連線確認）
        elif syn and ack:
            self.handle_syn_ack(conn_id, seq_num, ack_num)
        
        # 處理資料傳輸
        elif ack and data:
            self.handle_data(conn_id, seq_num, ack_num, data)
        
        # 處理 FIN（關閉連線）
        elif fin:
            self.handle_fin(conn_id, seq_num)
```

### 分散式系統基礎

實作簡單的分散式共識演算法（Raft）和分散式鎖服務。

```python
from enum import Enum
import random
import time

class NodeState(Enum):
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    LEADER = "leader"

class RaftNode:
    def __init__(self, node_id: str, peers: List[str]):
        self.node_id = node_id
        self.peers = peers
        self.state = NodeState.FOLLOWER
        
        # 持久化狀態
        self.current_term = 0
        self.voted_for = None
        self.log = []
        
        # 易失狀態
        self.commit_index = 0
        self.last_applied = 0
        
        # Leader 狀態
        self.next_index = {}
        self.match_index = {}
        
        # 選舉計時器
        self.election_timeout = random.uniform(150, 300)  # 毫秒
        self.last_heartbeat = time.time()
        
    def start_election(self):
        """開始選舉過程"""
        self.state = NodeState.CANDIDATE
        self.current_term += 1
        self.voted_for = self.node_id
        
        votes_received = 1  # 投給自己
        
        # 向所有節點請求投票
        for peer in self.peers:
            vote_granted = self.request_vote(peer)
            if vote_granted:
                votes_received += 1
        
        # 檢查是否獲得多數票
        if votes_received > (len(self.peers) + 1) // 2:
            self.become_leader()
    
    def request_vote(self, peer: str) -> bool:
        """向對等節點請求投票"""
        request = {
            'term': self.current_term,
            'candidate_id': self.node_id,
            'last_log_index': len(self.log) - 1,
            'last_log_term': self.log[-1]['term'] if self.log else 0
        }
        
        # 發送 RPC 請求（簡化版）
        response = self.send_rpc(peer, 'RequestVote', request)
        
        if response['term'] > self.current_term:
            self.current_term = response['term']
            self.state = NodeState.FOLLOWER
            self.voted_for = None
            return False
        
        return response['vote_granted']
    
    def become_leader(self):
        """成為領導者"""
        self.state = NodeState.LEADER
        
        # 初始化 leader 狀態
        for peer in self.peers:
            self.next_index[peer] = len(self.log)
            self.match_index[peer] = 0
        
        # 發送心跳
        self.send_heartbeats()
    
    def append_entries(self, entries: List[dict]):
        """追加日誌條目（Leader 使用）"""
        if self.state != NodeState.LEADER:
            return False
        
        # 添加到本地日誌
        for entry in entries:
            entry['term'] = self.current_term
            self.log.append(entry)
        
        # 複製到 followers
        success_count = 1  # 包含 leader 自己
        
        for peer in self.peers:
            if self.replicate_to_follower(peer, entries):
                success_count += 1
        
        # 檢查是否可以提交
        if success_count > (len(self.peers) + 1) // 2:
            self.commit_index = len(self.log) - 1
            return True
        
        return False
    
    def replicate_to_follower(self, peer: str, entries: List[dict]) -> bool:
        """將日誌條目複製到 follower"""
        prev_log_index = self.next_index[peer] - 1
        prev_log_term = self.log[prev_log_index]['term'] if prev_log_index >= 0 else 0
        
        request = {
            'term': self.current_term,
            'leader_id': self.node_id,
            'prev_log_index': prev_log_index,
            'prev_log_term': prev_log_term,
            'entries': entries,
            'leader_commit': self.commit_index
        }
        
        response = self.send_rpc(peer, 'AppendEntries', request)
        
        if response['success']:
            self.next_index[peer] = len(self.log)
            self.match_index[peer] = len(self.log) - 1
            return True
        else:
            # 處理日誌不一致
            self.next_index[peer] -= 1
            return False

class DistributedLock:
    def __init__(self, raft_cluster: List[RaftNode]):
        self.raft_cluster = raft_cluster
        self.locks = {}  # lock_name -> owner_info
        
    def acquire(self, lock_name: str, client_id: str, timeout: float = 10.0) -> bool:
        """獲取分散式鎖"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            # 建立鎖請求
            lock_request = {
                'operation': 'acquire',
                'lock_name': lock_name,
                'client_id': client_id,
                'timestamp': time.time()
            }
            
            # 透過 Raft 達成共識
            leader = self.find_leader()
            if leader and leader.append_entries([lock_request]):
                # 檢查鎖狀態
                if lock_name not in self.locks:
                    self.locks[lock_name] = {
                        'owner': client_id,
                        'acquired_at': time.time()
                    }
                    return True
                elif self.locks[lock_name]['owner'] == client_id:
                    # 重入鎖
                    return True
            
            time.sleep(0.1)  # 短暫等待後重試
        
        return False
    
    def release(self, lock_name: str, client_id: str) -> bool:
        """釋放分散式鎖"""
        if lock_name in self.locks and self.locks[lock_name]['owner'] == client_id:
            lock_release = {
                'operation': 'release',
                'lock_name': lock_name,
                'client_id': client_id,
                'timestamp': time.time()
            }
            
            leader = self.find_leader()
            if leader and leader.append_entries([lock_release]):
                del self.locks[lock_name]
                return True
        
        return False
```

透過這些進階實作，您已經掌握了現代計算機系統的核心技術。從管線化處理器到多核心並行計算，從快取一致性到分散式共識，這些概念構成了當今計算基礎設施的根基。

下一步建議您選擇一個特定領域深入研究，例如高效能計算、嵌入式系統或雲端基礎架構，並參與相關的開源專案來進一步提升實戰能力。記住，理論與實踐的結合是掌握系統架構的關鍵。
