description: 重構引擎執行腳本 - 自動化執行重構計畫
helper_scripts:
  batch_process:
    content: "#!/bin/bash\n# 批量處理 _legacy_scratch 中的所有資產\n\nSCRATCH_DIR=\"docs/refactor_playbooks/_legacy_scratch\"\
      \nOUTPUT_DIR=\"docs/refactor_playbooks/_legacy_scratch/analyzed\"\n\nmkdir -p\
      \ \"$OUTPUT_DIR\"\n\nfor file in \"$SCRATCH_DIR\"/*; do\n  if [ -f \"$file\"\
      \ ]; then\n    filename=$(basename \"$file\")\n    echo \"處理: $filename\"\n\
      \    python tools/process_legacy_scratch.py analyze \\\n      --asset \"$filename\"\
      \ \\\n      --output \"$OUTPUT_DIR/${filename%.}_decision.yaml\"\n  fi\ndone\n\
      \necho \"批量處理完成\"\n"
    name: batch_process.sh
  quick_analyze:
    content: "#!/bin/bash\n# 快速分析 refactor_playbooks 目錄\n\nTARGET=\"${1:-docs/refactor_playbooks}\"\
      \nOUTPUT=\"${2:-analysis_report.yaml}\"\n\npython tools/refactor_engine.py analyze\
      \ \\\n  --target \"$TARGET\" \\\n  --output \"$OUTPUT\" \\\n  --format yaml\n\
      \necho \"分析完成: $OUTPUT\"\n"
    name: quick_analyze.sh
  validate_all:
    content: '#!/bin/bash

      # 完整驗證 refactor_playbooks 結構


      TARGET="docs/refactor_playbooks"


      echo "=== 結構驗證 ==="

      python tools/validate_structure.py structure --target "$TARGET"


      echo ""

      echo "=== 引用驗證 ==="

      python tools/validate_structure.py references --target "$TARGET"


      echo ""

      echo "=== 索引驗證 ==="

      python tools/update_indexes.py verify


      echo ""

      echo "驗證完成"

      '
    name: validate_all.sh
name: ExecutionScripts
script_templates:
  main_executor_template: "#!/usr/bin/env python3\n\"\"\"\nRefactor Engine - 重構引擎主執行腳本\n\
    \nUsage:\n    python refactor_engine.py analyze --target <path>\n    python refactor_engine.py\
    \ plan --target <path> --output <file>\n    python refactor_engine.py execute\
    \ --plan <file> [--dry-run]\n\"\"\"\n\nimport argparse\nimport yaml\nimport os\n\
    import sys\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing\
    \ import Dict, List, Optional\n\n# ========================================================================\n\
    # 配置載入\n# ========================================================================\n\
    \ndef load_config(config_path: str) -> Dict:\n    \"\"\"載入配置檔案\"\"\"\n    with\
    \ open(config_path, 'r', encoding='utf-8') as f:\n        return yaml.safe_load(f)\n\
    \nCONFIG_PATH = \"docs/refactor_playbooks/config/refactor-engine-config.yaml\"\
    \nSCRATCH_CONFIG_PATH = \"docs/refactor_playbooks/config/legacy-scratch-processor.yaml\"\
    \nINTEGRATION_CONFIG_PATH = \"docs/refactor_playbooks/config/integration-processor.yaml\"\
    \n\n# ========================================================================\n\
    # 分析器\n# ========================================================================\n\
    \nclass DirectoryAnalyzer:\n    \"\"\"目錄分析器\"\"\"\n\n    def __init__(self, target_path:\
    \ str):\n        self.target = Path(target_path)\n        self.config = load_config(CONFIG_PATH)\n\
    \n    def analyze(self) -> Dict:\n        \"\"\"執行完整分析\"\"\"\n        return {\n\
    \            \"overview\": self._analyze_overview(),\n            \"problems\"\
    : self._identify_problems(),\n            \"structure\": self._analyze_structure(),\n\
    \            \"dependencies\": self._analyze_dependencies(),\n        }\n\n  \
    \  def _analyze_overview(self) -> Dict:\n        \"\"\"分析目錄概覽\"\"\"\n        files\
    \ = list(self.target.rglob(\"*\"))\n        return {\n            \"total_files\"\
    : len([f for f in files if f.is_file()]),\n            \"total_directories\":\
    \ len([f for f in files if f.is_dir()]),\n            \"max_depth\": self._calculate_max_depth(),\n\
    \            \"file_types\": self._count_file_types(),\n        }\n\n    def _identify_problems(self)\
    \ -> List[Dict]:\n        \"\"\"識別問題\"\"\"\n        problems = []\n        # TODO:\
    \ 實作問題識別邏輯\n        return problems\n\n    def _analyze_structure(self) -> Dict:\n\
    \        \"\"\"分析結構\"\"\"\n        # TODO: 實作結構分析\n        return {}\n\n    def\
    \ _analyze_dependencies(self) -> Dict:\n        \"\"\"分析依賴\"\"\"\n        # TODO:\
    \ 實作依賴分析\n        return {}\n\n    def _calculate_max_depth(self) -> int:\n  \
    \      \"\"\"計算最大深度\"\"\"\n        max_depth = 0\n        for path in self.target.rglob(\"\
    *\"):\n            depth = len(path.relative_to(self.target).parts)\n        \
    \    max_depth = max(max_depth, depth)\n        return max_depth\n\n    def _count_file_types(self)\
    \ -> Dict[str, int]:\n        \"\"\"統計檔案類型\"\"\"\n        counts = {}\n      \
    \  for file in self.target.rglob(\"*\"):\n            if file.is_file():\n   \
    \             ext = file.suffix or \"no_extension\"\n                counts[ext]\
    \ = counts.get(ext, 0) + 1\n        return counts\n\n# ========================================================================\n\
    # 計畫生成器\n# ========================================================================\n\
    \nclass PlanGenerator:\n    \"\"\"執行計畫生成器\"\"\"\n\n    def __init__(self, analysis:\
    \ Dict):\n        self.analysis = analysis\n        self.config = load_config(CONFIG_PATH)\n\
    \n    def generate(self) -> Dict:\n        \"\"\"生成執行計畫\"\"\"\n        return\
    \ {\n            \"metadata\": {\n                \"generated_at\": datetime.now().isoformat(),\n\
    \                \"version\": \"1.0.0\",\n            },\n            \"phases\"\
    : self._generate_phases(),\n            \"validation\": self._generate_validation_plan(),\n\
    \        }\n\n    def _generate_phases(self) -> List[Dict]:\n        \"\"\"生成各階段計畫\"\
    \"\"\n        phases = []\n        # TODO: 根據分析結果生成階段\n        return phases\n\
    \n    def _generate_validation_plan(self) -> Dict:\n        \"\"\"生成驗證計畫\"\"\"\
    \n        return {\n            \"structure_checks\": [],\n            \"reference_checks\"\
    : [],\n            \"quality_checks\": [],\n        }\n\n# ========================================================================\n\
    # 執行器\n# ========================================================================\n\
    \nclass Executor:\n    \"\"\"重構執行器\"\"\"\n\n    def __init__(self, plan: Dict,\
    \ dry_run: bool = True):\n        self.plan = plan\n        self.dry_run = dry_run\n\
    \        self.config = load_config(CONFIG_PATH)\n        self.executed_steps =\
    \ []\n\n    def execute(self) -> Dict:\n        \"\"\"執行計畫\"\"\"\n        results\
    \ = {\n            \"success\": True,\n            \"executed\": [],\n       \
    \     \"failed\": [],\n            \"skipped\": [],\n        }\n\n        for\
    \ phase in self.plan.get(\"phases\", []):\n            phase_result = self._execute_phase(phase)\n\
    \            results[\"executed\"].extend(phase_result[\"executed\"])\n      \
    \      results[\"failed\"].extend(phase_result[\"failed\"])\n\n            if\
    \ phase_result[\"failed\"]:\n                results[\"success\"] = False\n  \
    \              break\n\n        return results\n\n    def _execute_phase(self,\
    \ phase: Dict) -> Dict:\n        \"\"\"執行單一階段\"\"\"\n        result = {\"executed\"\
    : [], \"failed\": []}\n\n        for step in phase.get(\"steps\", []):\n     \
    \       if self.dry_run:\n                print(f\"[DRY-RUN] Would execute: {step}\"\
    )\n                result[\"executed\"].append(step)\n            else:\n    \
    \            try:\n                    self._execute_step(step)\n            \
    \        result[\"executed\"].append(step)\n                except Exception as\
    \ e:\n                    result[\"failed\"].append({\"step\": step, \"error\"\
    : str(e)})\n\n        return result\n\n    def _execute_step(self, step: Dict):\n\
    \        \"\"\"執行單一步驟\"\"\"\n        operation = step.get(\"operation\")\n   \
    \     # TODO: 實作各種操作\n        pass\n\n# ========================================================================\n\
    # CLI 入口\n# ========================================================================\n\
    \ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Refactor\
    \ Engine - 智能重構引擎\"\n    )\n\n    subparsers = parser.add_subparsers(dest=\"command\"\
    , help=\"可用命令\")\n\n    # analyze 命令\n    analyze_parser = subparsers.add_parser(\"\
    analyze\", help=\"分析目標目錄\")\n    analyze_parser.add_argument(\"--target\", required=True,\
    \ help=\"目標目錄\")\n    analyze_parser.add_argument(\"--output\", help=\"輸出檔案\"\
    )\n    analyze_parser.add_argument(\"--format\", default=\"yaml\", help=\"輸出格式\"\
    )\n\n    # plan 命令\n    plan_parser = subparsers.add_parser(\"plan\", help=\"\
    生成執行計畫\")\n    plan_parser.add_argument(\"--target\", required=True, help=\"目標目錄\"\
    )\n    plan_parser.add_argument(\"--output\", required=True, help=\"計畫輸出路徑\")\n\
    \    plan_parser.add_argument(\"--priority\", default=\"all\", help=\"優先級篩選\"\
    )\n\n    # execute 命令\n    execute_parser = subparsers.add_parser(\"execute\"\
    , help=\"執行重構\")\n    execute_parser.add_argument(\"--plan\", required=True, help=\"\
    計畫檔案\")\n    execute_parser.add_argument(\"--dry-run\", action=\"store_true\"\
    , help=\"模擬執行\")\n    execute_parser.add_argument(\"--confirm\", action=\"store_true\"\
    , help=\"確認執行\")\n    execute_parser.add_argument(\"--phase\", type=int, help=\"\
    指定階段\")\n\n    # validate 命令\n    validate_parser = subparsers.add_parser(\"validate\"\
    , help=\"驗證結果\")\n    validate_parser.add_argument(\"--target\", required=True,\
    \ help=\"目標目錄\")\n    validate_parser.add_argument(\"--report\", action=\"store_true\"\
    , help=\"生成報告\")\n\n    args = parser.parse_args()\n\n    if args.command == \"\
    analyze\":\n        analyzer = DirectoryAnalyzer(args.target)\n        result\
    \ = analyzer.analyze()\n\n        if args.output:\n            with open(args.output,\
    \ 'w', encoding='utf-8') as f:\n                if args.format == \"yaml\":\n\
    \                    yaml.dump(result, f, allow_unicode=True, default_flow_style=False)\n\
    \                else:\n                    import json\n                    json.dump(result,\
    \ f, indent=2, ensure_ascii=False)\n        else:\n            print(yaml.dump(result,\
    \ allow_unicode=True, default_flow_style=False))\n\n    elif args.command == \"\
    plan\":\n        analyzer = DirectoryAnalyzer(args.target)\n        analysis =\
    \ analyzer.analyze()\n        generator = PlanGenerator(analysis)\n        plan\
    \ = generator.generate()\n\n        with open(args.output, 'w', encoding='utf-8')\
    \ as f:\n            yaml.dump(plan, f, allow_unicode=True, default_flow_style=False)\n\
    \        print(f\"計畫已生成: {args.output}\")\n\n    elif args.command == \"execute\"\
    :\n        with open(args.plan, 'r', encoding='utf-8') as f:\n            plan\
    \ = yaml.safe_load(f)\n\n        dry_run = args.dry_run or not args.confirm\n\
    \        executor = Executor(plan, dry_run=dry_run)\n        result = executor.execute()\n\
    \n        if result[\"success\"]:\n            print(\"✅ 執行成功\")\n        else:\n\
    \            print(\"❌ 執行失敗\")\n            for fail in result[\"failed\"]:\n\
    \                print(f\"  - {fail}\")\n\n    elif args.command == \"validate\"\
    :\n        # TODO: 實作驗證邏輯\n        print(f\"驗證 {args.target}...\")\n\n    else:\n\
    \        parser.print_help()\n\nif __name__ == \"__main__\":\n    main()\n"
scripts:
  index_updater:
    commands:
      all:
        description: 更新所有索引
      human:
        description: 更新 INDEX.md
      legacy:
        description: 更新 legacy_assets_index.yaml
      machine:
        description: 更新 index.yaml
      verify:
        description: 驗證索引與實際結構同步
    description: 更新各種索引檔案
    location: tools/update_indexes.py
    name: update_indexes.py
    usage: '# 更新所有索引

      python tools/update_indexes.py all


      # 只更新 index.yaml

      python tools/update_indexes.py machine


      # 只更新 INDEX.md

      python tools/update_indexes.py human


      # 驗證索引同步

      python tools/update_indexes.py verify

      '
  integration_executor:
    commands:
      batch:
        description: 批量執行集成
        options:
        - '--decisions: 決策檔案目錄'
        - '--parallel: 並行數'
      reorganize:
        description: 整個子目錄重組
        options:
        - '--target: 目標目錄'
        - '--plan: 重組計畫'
      single:
        description: 執行單一資產的集成
        options:
        - '--decision: 決策檔案'
        - '--dry-run: 模擬執行'
    description: 執行集成操作
    location: tools/execute_integration.py
    name: execute_integration.py
    usage: '# 執行單一集成

      python tools/execute_integration.py single --decision placement_decision.yaml


      # 批量集成

      python tools/execute_integration.py batch --decisions analyzed/


      # 子目錄重組

      python tools/execute_integration.py reorganize --target docs/refactor_playbooks

      '
  main_executor:
    commands:
      analyze:
        description: 分析目標目錄，生成分析報告
        options:
        - '--target: 目標目錄路徑'
        - '--output: 輸出報告路徑'
        - '--format: 輸出格式 (md|yaml|json)'
      execute:
        description: 執行重構計畫
        options:
        - '--plan: 計畫檔案路徑'
        - '--dry-run: 模擬執行'
        - '--confirm: 確認執行'
        - '--phase: 指定階段 (1-9)'
      plan:
        description: 根據分析結果生成執行計畫
        options:
        - '--target: 目標目錄'
        - '--output: 計畫輸出路徑'
        - '--priority: 優先級篩選 (P1|P2|P3|all)'
      rollback:
        description: 回滾到之前的狀態
        options:
        - '--checkpoint: 檢查點 ID'
        - '--steps: 回滾步數'
      validate:
        description: 驗證執行結果
        options:
        - '--target: 目標目錄'
        - '--report: 生成驗證報告'
    description: 重構引擎主執行腳本
    location: tools/refactor_engine.py
    name: refactor_engine.py
    usage: '# 分析模式 - 生成分析報告

      python tools/refactor_engine.py analyze --target docs/refactor_playbooks


      # 規劃模式 - 生成執行計畫

      python tools/refactor_engine.py plan --target docs/refactor_playbooks --output
      plan.yaml


      # 執行模式 - 執行重構 (dry-run)

      python tools/refactor_engine.py execute --plan plan.yaml --dry-run


      # 執行模式 - 實際執行

      python tools/refactor_engine.py execute --plan plan.yaml --confirm

      '
  scratch_processor:
    commands:
      analyze:
        description: 分析單一資產
        options:
        - '--asset: 資產檔案名'
        - '--deep: 深度分析'
      batch:
        description: 批量處理所有資產
        options:
        - '--all: 處理所有'
        - '--filter: 過濾條件'
      decide:
        description: 生成位置決策報告
        options:
        - '--asset: 資產檔案名'
        - '--output: 輸出路徑'
      scan:
        description: 掃描暫存區中的所有資產
        output: asset_inventory.yaml
    description: 處理 _legacy_scratch 暫存區的舊資產
    location: tools/process_legacy_scratch.py
    name: process_legacy_scratch.py
    usage: '# 掃描暫存區

      python tools/process_legacy_scratch.py scan


      # 分析單一資產

      python tools/process_legacy_scratch.py analyze --asset axiom_complete_architecture.txt


      # 生成決策報告

      python tools/process_legacy_scratch.py decide --asset axiom_complete_architecture.txt


      # 批量處理

      python tools/process_legacy_scratch.py batch --all

      '
  validator:
    commands:
      full:
        description: 執行完整驗證
      naming:
        description: 只驗證命名
      references:
        description: 只驗證引用
      report:
        description: 生成驗證報告
      structure:
        description: 只驗證結構
    description: 驗證目錄結構正確性
    location: tools/validate_structure.py
    name: validate_structure.py
    usage: '# 完整驗證

      python tools/validate_structure.py full --target docs/refactor_playbooks


      # 結構驗證

      python tools/validate_structure.py structure


      # 引用驗證

      python tools/validate_structure.py references


      # 生成報告

      python tools/validate_structure.py report --output validation_report.md

      '
usage_guide:
  quick_start: "## 快速開始\n\n1. 分析目錄：\n   ```bash\n   python tools/refactor_engine.py\
    \ analyze --target docs/refactor_playbooks\n   ```\n\n2. 生成計畫：\n   ```bash\n \
    \  python tools/refactor_engine.py plan --target docs/refactor_playbooks --output\
    \ plan.yaml\n   ```\n\n3. 模擬執行：\n   ```bash\n   python tools/refactor_engine.py\
    \ execute --plan plan.yaml --dry-run\n   ```\n\n4. 實際執行：\n   ```bash\n   python\
    \ tools/refactor_engine.py execute --plan plan.yaml --confirm\n   ```\n"
  title: 重構引擎使用指南
  workflow: '## 完整工作流程


    ### 第一輪：分析與規劃

    1. 將舊資產放入 `_legacy_scratch/intake/`

    2. 執行掃描：`python tools/process_legacy_scratch.py scan`

    3. 分析資產：`python tools/process_legacy_scratch.py analyze --all`

    4. 生成決策：`python tools/process_legacy_scratch.py decide --all`

    5. 審查決策報告


    ### 第二輪：執行與驗證

    1. 根據決策報告生成執行計畫

    2. 執行 dry-run 確認無誤

    3. 執行實際重構

    4. 更新所有索引

    5. 執行完整驗證

    6. 生成完成報告

    '
version: 1.0.0
